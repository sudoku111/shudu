import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * 
 * @author hjq&jtl
 *
 */
public class Sudoku extends JFrame {

	private JPanel[] pnlGame;
	/** 数独文本框 */
	private static JTextField[][][] txtGame;
	/** 光标所在文本框 */
	private JTextField lastFocusTextFiled;
	/** 从题目文件获取的数独数组 */
	private static String[][] n = new String[9][9];
        /**显示时间的标签**/
	private JLabel time;
        /**计时器**/
	private CountingThread thread = new CountingThread();
	/** 游戏初始时间 */
	private static long programStart;
	/** 判断游戏是否应该继续 */
	private static boolean goOn = true;
	/**记录每次游戏用时**/
	private static long elapsed;
	/**判断是不是第一次游戏要不要启动计时器**/
	private static int count2 = 0;
	/** 时间最短记录 */
	private static long timeRecord;
	/** 存放冲突域的两个文本框 */
	private static Map<JTextField, JTextField> warnFiledMap = new HashMap<JTextField, JTextField>();
	/** 难度按钮组 */
	private ButtonGroup group;
	/** 题目文件的序号 */
	private static int count;
	/** 提示次数 */
	private static int t = 3;

	// 焦点监听器
	private FocusListener textFocusListener = new FocusListener() {
		@Override
		public void focusGained(FocusEvent e) {
			lastFocusTextFiled = (JTextField) e.getComponent();
		}

		@Override
		public void focusLost(FocusEvent e) {
			lastFocusTextFiled = (JTextField) e.getComponent();
		}
	};

	/** 构造数独实例 */
	public Sudoku() {
		pnlGame = new JPanel[12];
		txtGame = new JTextField[9][3][3];
		gridInit();
	}

	/** 游戏初始化 */
	public void gridInit() {
		this.setDefaultCloseOperation(this.EXIT_ON_CLOSE);// 设置可关闭
		this.setSize(800, 600);//设置窗口大小
		this.setResizable(false);// 用户不可调整大小
		this.setTitle("Suduko");//设置窗口标题
		this.setLayout(new GridLayout(3, 4));// 设置布局

		try {// 读取存档
			n = readfromFile("save.txt");
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
		}

		for (int i = 0; i < 12; i++) {
			if ((i + 1) % 4 != 0) {// 设置数独格
				pnlGame[i] = new JPanel();
				pnlGame[i].setBorder(BorderFactory.createLineBorder(Color.black));//设置边框
				pnlGame[i].setLayout(new GridLayout(3, 3));//设置布局
				this.add(pnlGame[i]);
			} else if (i == 3) {// 设置三个按钮
				JButton btn1 = new JButton("新游戏");
				JButton btn2 = new JButton("存档");
				JButton btn3 = new JButton("读档");

				// 新游戏按钮监听
				btn1.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent e) {
						// 设置初始时间
						programStart = System.currentTimeMillis();
						if (count2 == 0) {
							// 计时器启动
							thread.start();
							count2++;
						}
						thread.goOn = true;
						String[][] n = new String[9][9];
						if (count == 10 || count == 30 || count == 50)
							count = count - 10;// 避免超出题库范围
						count++;//依次读取题目
						try { // 从文件中读取题目
							n = readfromFile(String.format("%d.txt", count));
						} catch (FileNotFoundException e1) {
							e1.printStackTrace();
						}

						// 将题目填入九宫格中
						for (int z = 0; z < 3; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x][y + 3 * z].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x][y + 3 * z]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
						for (int z = 3; z < 6; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x + 3][y + 3 * (z - 3)].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x + 3][y + 3 * (z - 3)]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
						for (int z = 6; z < 9; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x + 6][y + 3 * (z - 6)].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x + 6][y + 3 * (z - 6)]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
						for (int z = 0; z < 9; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									// 所有文本框中文字恢复黑色
									txtGame[z][x][y].setForeground(Color.black);
								}
							}
						}
						goOn = true;
					}
				});

				// 存档按钮监听
				btn2.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent e) {
						try {
							SaveIntoFile(txtGame);
						} catch (FileNotFoundException e1) {
							e1.printStackTrace();
						}
					}
				});

				// 读档按钮监听
				btn3.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent e) {
						// 重新设置初始时间
						programStart = System.currentTimeMillis();
						// 开始计时
						goOn = true;
						String[][] n = new String[9][9];
						
						try {// 读取存档
							n = readfromFile("save.txt");
						} catch (FileNotFoundException e1) {
							e1.printStackTrace();
						}
						// 填入九宫格
						for (int z = 0; z < 3; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x][y + 3 * z].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x][y + 3 * z]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
						for (int z = 3; z < 6; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x + 3][y + 3 * (z - 3)].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x + 3][y + 3 * (z - 3)]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
						for (int z = 6; z < 9; z++) {
							for (int x = 0; x < 3; x++) {
								for (int y = 0; y < 3; y++) {
									if (n[x + 6][y + 3 * (z - 6)].equals("0")) {
										txtGame[z][x][y].setText("");
										txtGame[z][x][y].setEditable(true);
									} else {
										txtGame[z][x][y].setText(n[x + 6][y + 3 * (z - 6)]);
										txtGame[z][x][y].setEditable(false);
									}
								}
							}
						}
					}
				});
				pnlGame[i] = new JPanel();
				/**把三个button加入panel**/
				pnlGame[i].add(btn2);
				pnlGame[i].add(btn3);
				pnlGame[i].add(btn1);
				this.add(pnlGame[i]);
			} else if (i == 7) {// 难易选择
				group = new ButtonGroup();
				pnlGame[i] = new JPanel();
				addJRadioButton("易", i);
				addJRadioButton("中", i);
				addJRadioButton("难", i);
				time = new JLabel("00:00:00 000");//时间显示
				pnlGame[i].add(time);
				this.add(pnlGame[i]);
			} else {// 提示
				pnlGame[i] = new JPanel();
				// 创建提示按钮
				JButton btn3 = new JButton("提示");
				JTextField time = new JTextField();// 显示提示次数
				time.setText(String.valueOf(t));
				time.setEditable(false);
				pnlGame[i].add(time);
				// 给提示按钮增加监听和功能
				btn3.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent e) {
						if (lastFocusTextFiled == null) {
							System.err.println("Please select a text field");
							return;
						}

						if (t > 0) {
							t--;//每次提示过后提示次数减少
							time.setEditable(true);
							time.setText(String.valueOf(t));//更改提示次数
							time.setEditable(false);
							String[][] n = new String[9][9];
							try {// 从文件中读取答案
								n = readfromFile(String.format("%d.txt", count + 10));
							} catch (FileNotFoundException e1) {
								e1.printStackTrace();
							}
							// 获得需要提示的txt位置
							lastFocusTextFiled.setText("");
							for (int z = 0; z < 9; z++) {
								for (int x = 0; x < 3; x++) {
									for (int y = 0; y < 3; y++) {
										if (txtGame[z][x][y] == lastFocusTextFiled) {
											txtGame[z][x][y].setText(n[Cell.getX(z, x)][Cell.getY(z, y)]);
											txtGame[z][x][y].setEditable(false);
										}
									}
								}
							}
						} else {
							// 当提示次数用完时进行提醒
							JDialog dialog = new JDialog();// 创建新的对话框
							dialog.setBounds(300, 200, 300, 200);
							dialog.setVisible(true);
							JLabel jl2 = new JLabel("你的提示次数已用完，点击确定继续");
							final JButton but = new JButton("确定");// 设置确定按钮，点击关闭对话框继续游戏
							dialog.setModal(true);
							dialog.setLayout(new FlowLayout());//设置布局
							dialog.add(jl2);
							dialog.add(but);
							but.addActionListener(new ActionListener() {
								@Override
								public void actionPerformed(ActionEvent e) {
									dialog.dispose();//关闭对话框
								}
							});
						}
					}
				});

				pnlGame[i].add(btn3);
				this.add(pnlGame[i]);
			}

		}

		// 填数独
		int tt = 0;
		for (int z = 0; z < 9; z++) {
			if ((z + 1 + tt) % 4 == 0)
				tt++;
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					txtGame[z][x][y] = new JTextField();
					txtGame[z][x][y].addFocusListener(textFocusListener);
					txtGame[z][x][y].setBorder(BorderFactory.createEtchedBorder());
					txtGame[z][x][y].setFont(new Font("Dialog", Font.ITALIC, 20));
					txtGame[z][x][y].setHorizontalAlignment(JTextField.CENTER);
					pnlGame[z + tt].add(txtGame[z][x][y]);
				}
			}
		}
		addCheck();
		this.setVisible(true);
	}

	/**添加文本框监听*/
	public void addCheck() {
		for (int z = 0; z < 9; z++) {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					int i = z, j = x, k = y;
					txtGame[z][x][k].getDocument().addDocumentListener(new DocumentListener() {
						@Override
						public void insertUpdate(DocumentEvent e) {
							checkWhenChange(i, j, k);
						}

						@Override
						public void removeUpdate(DocumentEvent e) {
							checkWhenChange(i, j, k);
						}

						@Override
						public void changedUpdate(DocumentEvent e) {
							checkWhenChange(i, j, k);
						}
					});
				}
			}
		}
	}

	/** 当文本框输入数字判断是否冲突 */
	private static void checkWhenChange(int z, int x, int y) {
		if (warnFiledMap.size() != 0) {
			// 如果修改冲突域的数字
			if (warnFiledMap.get(txtGame[z][x][y]) != null) {
				if (!txtGame[z][x][y].getText().equals(warnFiledMap.get(txtGame[z][x][y]).getText())) {
					txtGame[z][x][y].setForeground(Color.black);
					warnFiledMap.get(txtGame[z][x][y]).setForeground(Color.black);
					// 清空冲突域
					warnFiledMap.remove(txtGame[z][x][y]);
				}
			}
		}
		check(z, x, y);
	}

	/** 判断输入数字是否冲突 */
	private static void check(int z0, int x0, int y0) {
		// 以z小九宫格为标准，x轴方向遍历
		int[] xAxis = new int[2];
		// 以z小九宫格为标准，y轴方向遍历
		int[] yAxis = new int[2];
		String value = txtGame[z0][x0][y0].getText().trim();
		// 如果是0, 3 ,6 小九宫格，检查右面2个小九宫格
		if (z0 == 0 || z0 == 3 || z0 == 6) {
			xAxis[0] = z0 + 1;
			xAxis[1] = z0 + 2;
		} // 如果是1, 4, 7 小九宫格，检查左右两边的小九宫格
		else if (z0 == 1 || z0 == 4 || z0 == 7) {
			xAxis[0] = z0 - 1;
			xAxis[1] = z0 + 1;
		} // 如果是2, 5, 8 小九宫格，检查左面2个小九宫格
		else if (z0 == 2 || z0 == 5 || z0 == 8) {
			xAxis[0] = z0 - 2;
			xAxis[1] = z0 - 1;
		}
		// 6,7,8小九宫格 检查上面2个小九宫格
		if (z0 >= 6) {
			yAxis[0] = z0 - 6;
			yAxis[1] = z0 - 3;
		} // 3,4,5小九宫格 检查上下两个小九宫格
		else if (z0 >= 3 && z0 < 6) {
			yAxis[0] = z0 - 3;
			yAxis[1] = z0 + 3;
		} // 0,1,2小九宫格 检查下面2个小九宫格
		else if (z0 < 3) {
			yAxis[0] = z0 + 3;
			yAxis[1] = z0 + 6;
		}
		int z;
		// 检查同一列中已存在的数据
		for (int i = 0; i < 2; i++) {
			z = yAxis[i];
			for (int x = 0; x < 3; x++) {
				if (txtGame[z][x][y0].getText().equals(value)) {
					txtGame[z][x][y0].setForeground(Color.red);
					txtGame[z0][x0][y0].setForeground(Color.red);
					// 将冲突的两个文本框中的数字交替放入map中
					warnFiledMap.put(txtGame[z][x][y0], txtGame[z0][x0][y0]);
					warnFiledMap.put(txtGame[z0][x0][y0], txtGame[z][x][y0]);
					return;
				}
			}
		}
		// 检查同一行中已存在的数据
		for (int i = 0; i < 2; i++) {
			z = xAxis[i];
			for (int y = 0; y < 3; y++) {
				if (txtGame[z][x0][y].getText().equals(value)) {
					txtGame[z][x0][y].setForeground(Color.red);
					txtGame[z0][x0][y0].setForeground(Color.red);
					// 将冲突的两个文本框中的数字交替放入map中
					warnFiledMap.put(txtGame[z][x0][y], txtGame[z0][x0][y0]);
					warnFiledMap.put(txtGame[z0][x0][y0], txtGame[z][x0][y]);
					return;
				}
			}
		}
		// 检查小九宫格内部数字
		for (int x = 0; x < 3; x++) {
			for (int y = 0; y < 3; y++) {
				if (!(x == x0 && y == y0) && txtGame[z0][x][y].getText().equals(value)) {
					txtGame[z0][x][y].setForeground(Color.red);
					txtGame[z0][x0][y0].setForeground(Color.red);
					// 将冲突的两个文本框中的数字交替放入map中
					warnFiledMap.put(txtGame[z0][x][y], txtGame[z0][x0][y0]);
					warnFiledMap.put(txtGame[z0][x0][y0], txtGame[z0][x][y]);
					return;
				}
			}
		}
	}

	public static void main(String[] args) throws FileNotFoundException {// TODO
		Sudoku s = new Sudoku();// 开始游戏
		boolean e = true;
		while (e) {
			while (!goOn) {// 等待新游戏的开始
				try {
					Thread.sleep(10);
				} catch (Exception exc) {
					exc.printStackTrace();
				}
			}
			// 如果未结束则不能继续进行
			while (!end() && goOn) {
				try {
					Thread.sleep(10);
				} catch (Exception exc) {
					exc.printStackTrace();
				}
			}

			if (end() && goOn) {// 如果结束弹出窗口
				goOn = false;// 停止计时
				s.thread.goOn = false;
				// 找出最高记录并将本次用时写入文档
				compareTime(elapsed);
				// 创建新的对话框
				JDialog dialog = new JDialog();
				dialog.setBounds(300, 200, 600, 400);
				dialog.setVisible(true);

				// 弹出游戏结束对话框
				JLabel jl2 = new JLabel(
						"游戏结束！ 用时  " + format(elapsed) + "最高纪录为  " + format(timeRecord) + "  点击确定继续" + " 请手动开始新游戏");
				final JButton but = new JButton("确定");
				dialog.setModal(true);
				dialog.setLayout(new FlowLayout());
				dialog.add(jl2);
				dialog.add(but);
				// 点击确定按钮关闭对话框
				but.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent e) {
						dialog.dispose();
					}
				});
			}
		}
	}

	/** 判断游戏是否结束 */
	private static boolean end() {
		int empty = 0;
		// 判断数独格子有几个是空的
		for (int z = 0; z < 9; z++) {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (txtGame[z][x][y].getText().isEmpty())
						empty++;
				}
			}
		}
		// 格子全部填满结束
		return empty == 0;
	}

	/** 读取文件 */
	public static String[][] readfromFile(String filename) throws FileNotFoundException {
		String[][] s = new String[9][9];
		File inputFile = new File(filename);
		Scanner input = new Scanner(inputFile);
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				s[i][j] = input.next();
			}
		}
		return s;
	}

	/** 添加难度选择按钮 */
	private void addJRadioButton(final String text, int i) {
		JRadioButton radioButton = new JRadioButton(text);
		group.add(radioButton);
		pnlGame[i].add(radioButton);
		radioButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				// 选择易则从零号题目开始
				if ("易".equals(text))
					count = 0;
				// 选择中则从十号题目开始
				else if ("中".equals(text))
					count = 20;
				// 选择难则从二十号题目开始
				else if ("难".equals(text))
					count = 40;
				// 默认难度为易
				else
					count = 0;
			}
		});
	}

	/** 存档 */
	public static void SaveIntoFile(JTextField[][][] tf) throws FileNotFoundException {
		String[][] s = new String[9][9];// 存入文件的数独数组

		for (int z = 0; z < 9; z++) {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (!tf[z][x][y].getText().isEmpty())
						s[Cell.getX(z, x)][Cell.getY(z, y)] = tf[z][x][y].getText();
					else
						s[Cell.getX(z, x)][Cell.getY(z, y)] = "0";
				}
			}
		}
		PrintWriter output = new PrintWriter("save.txt");
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				output.print(s[i][j] + "  ");
			}
			output.println();
		}
		output.close();
	}

	/**
	 * 
	 * @author hjq
	 *
	 */
	private class CountingThread extends Thread {
		/** 判断是否继续计时 */
		public boolean goOn = true;

		private CountingThread() {
			setDaemon(true);
		}

		@Override
		public void run() {
			// 开始计时
			while (true) {
				if (goOn) {
					elapsed = System.currentTimeMillis() - programStart;
					// 把毫秒转化成时分秒的格式
					time.setText(format(elapsed));
				}
				try {// 1毫秒更新一次显示
					sleep(1);
				} catch (InterruptedException e) {
					e.printStackTrace();
					System.exit(1);
				}
			}
		}
	}

	/** 转化时间的格式 */
	public static String format(long elapsed) {
		int hour, minute, second, milli;
		milli = (int) (elapsed % 1000);
		elapsed = elapsed / 1000;
		second = (int) (elapsed % 60);
		elapsed = elapsed / 60;
		minute = (int) (elapsed % 60);
		elapsed = elapsed / 60;
		hour = (int) (elapsed % 60);
		return String.format("%02d:%02d:%02d %03d", hour, minute, second, milli);
	}

	/** 在现有的时间记录中找到最高纪录 */
	private static void compareTime(long t) throws FileNotFoundException {
		write(t);//把本次时间写入文档保存
		File inputFile = new File("record.txt");//读取文档里面的时间记录
		Scanner input = new Scanner(inputFile);
		timeRecord = input.nextLong();
		long l = -1;
		while (input.hasNextLong()) {//得到最高纪录
			l = input.nextLong();
			if (l < timeRecord)
				timeRecord = l;
		}
	}

	/** 把此次时间写入文档中保存 */
	private static void write(long t) {
		FileOutputStream o = null;

		byte[] buff = new byte[] {};

		try {
			File file = new File("record.txt");
			if (!file.exists()) {//如果不存在则创建新文档
				file.createNewFile();
			}

			buff = String.valueOf(t).getBytes();//把时间转换成字符格式

			o = new FileOutputStream(file, true);//可以后续增加内容

			o.write(buff);//把时间写入
			byte[] bu = new byte[] { ' ' };//空格分割每次时间
			o.write(bu);
			o.flush();

			o.close();//关闭文档

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}
